#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>
#include <stdio.h>
#include <string.h>
#include <string>
#include <unistd.h>

#define ILOG(FMT, ...)                                                         \
  printf("INFO %s:%d] "##FMT##"\n", __FILE__, __LINE__, __VA_ARGS__)
#define ELOG(CODE, FMT, ...)                                                   \
  do {                                                                         \
    fprintf(stderr, "ERROR %s:%d] " FMT "\n", __FILE__, __LINE__,              \
            __VA_ARGS__);                                                      \
    return CODE;                                                               \
  } while (0)

const char *prelude1 =
    R"(# This file was autogenerated by the Greninja build system.
root=.
builddir=build
c = clang
cxx = clang++)";

const char *dbgprelude = R"(
cflags = -g -Wall -Wextra -O0
)";

const char *optprelude = R"(
cflags = -Wall -Wextra -O3 -DNDEBUG
)";

const char *prelude2 = R"(
rule c
    command = $c -MMD -MT $out -MF $out.d $cflags -c $in -o $out
    description = C $out
    depfile = $out.d
    deps = gcc

rule cxx
    command = $cxx -MMD -MT $out -MF $out.d $cflags -c $in -o $out
    description = CXX $out
    depfile = $out.d
    deps = gcc

rule ar
  command = rm -f $out && $ar crs $out $in
  description = AR $out

rule link
  command = $cxx -o $out $in $libs
  description = LINK $out

rule install
  command = sudo /usr/bin/install $in /usr/bin
  description = INSTALL $in

rule clean
  command = rm $builddir/*
  description = CLEAN

rule default
  command = echo Specify a build target!


build default: default $root
default default
build clean: clean $builddir
)";

int main(int argc, char **argv) {
  if (argc != 2) {
    ELOG(-1, "Incorrect arg count! Expected 2, got %d", argc);
  }
  const char *const mode = argv[1];
  const bool isdbg = strcmp(mode, "dbg") == 0;
  const bool isopt = strcmp(mode, "opt") == 0;
  const bool isclean = strcmp(mode, "clean") == 0;
  if (!isdbg && !isopt && !isclean) {
    ELOG(-1, "Invalid mode \"%s\", expected \"dbg\", \"opt\", \"clean\"", mode);
  }
  if (isclean) {
    execl("/usr/bin/rm", "rm", "-rf", "build", "build.ninja", NULL);
    return 0;
  }

  std::ofstream os("build.ninja");
  std::ifstream is("build.gn");
  os << prelude1 << (isdbg ? dbgprelude : optprelude) << prelude2;
  while (!is.eof()) {
    std::string t;
    std::getline(is, t);
    if (std::all_of(t.begin(), t.end(),
                    [](char c) { return std::isspace(c); })) {
      continue;
    }
    std::stringstream ss(t);

    std::string method;
    std::string name;
    ss >> method >> name;
    if (method == "c") {
      os << "build $builddir/" << name << ".o: c";
      while (!ss.eof()) {
        std::string t;
        ss >> t;
        os << " $root/" << t;
      }
    } else if (method == "cxx") {
      os << "build $builddir/" << name << ".o: cxx";
      while (!ss.eof()) {
        std::string t;
        ss >> t;
        os << " $root/" << t;
      }
    } else if (method == "lib") {
      os << "build $builddir/" << name << ".a: ar";
      while (!ss.eof()) {
        std::string t;
        ss >> t;
        os << " $builddir/" << t;
      }
    } else if (method == "bin") {
      os << "build $builddir/" << name << ": link";
      while (!ss.eof()) {
        std::string t;
        ss >> t;
        os << " $builddir/" << t;
      }
    } else if (method == "install_bin") {
      os << "build install_" << name << ": install $builddir/" << name
         << "\n  pool = console";
    } else {
      ELOG(-1, "Invalid method %s!", method.c_str());
    }
    os << "\n";
  }
}
